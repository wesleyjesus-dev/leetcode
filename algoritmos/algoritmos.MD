No estudos dos algoritmos utilizamos a nota√ß√£o Big O para descrever sua performance.

O pior desempenho de um algoritmo √© uma medida da complexidade no cenario mais desfavoravel.

Tipos de complexidades da mais rapida para a mais lenta

1. O(1) ‚Äî Tempo constante
Exemplo: Acessar diretamente um elemento em um array (por √≠ndice).
O tempo de execu√ß√£o n√£o aumenta √† medida que a entrada cresce.
Pior caso: O mesmo n√∫mero de opera√ß√µes, independentemente do tamanho da entrada.

2. O(logn) ‚Äî Tempo logar√≠tmico
Exemplo: Busca bin√°ria.
O n√∫mero de opera√ß√µes aumenta logaritmicamente conforme a entrada aumenta.
Pior caso: Executa opera√ß√µes proporcionalmente ao logaritmo do tamanho da entrada.

3. O(n) ‚Äî Tempo linear
Exemplo: Percorrer uma lista para encontrar um elemento.
O tempo de execu√ß√£o cresce linearmente com o tamanho da entrada.
Pior caso: Para uma entrada de tamanho ùëõ n, voc√™ precisa realizar ùëõ n opera√ß√µes.

4. O(n logn) ‚Äî Tempo linear√≠tmico
Exemplo: Algoritmos de ordena√ß√£o eficientes, como Merge Sort ou Quick Sort.
O tempo de execu√ß√£o cresce mais r√°pido que linear, mas ainda √© considerado eficiente.
Pior caso: Realiza ùëõ log ùëõ
nlogn opera√ß√µes.

5. O(n 2) ‚Äî Tempo quadr√°tico
Exemplo: Bubble Sort, Insertion Sort no pior caso.
O tempo de execu√ß√£o cresce proporcionalmente ao quadrado do tamanho da entrada.
Pior caso: Muito ineficiente para entradas grandes.

6. O(n 3) ‚Äî Tempo c√∫bico
Exemplo: Algoritmos de multiplica√ß√£o de matrizes.
O tempo de execu√ß√£o cresce proporcionalmente ao cubo do tamanho da entrada.
Pior caso: Cada aumento no tamanho da entrada resulta em um crescimento c√∫bico nas opera√ß√µes.

7. O(2 n) ‚Äî Tempo exponencial
Exemplo: Resolver o problema da Mochila (Knapsack Problem) usando for√ßa bruta, alguns algoritmos de backtracking.
O tempo de execu√ß√£o dobra para cada incremento no tamanho da entrada.
Pior caso: Extremamente ineficiente para entradas grandes, pois o tempo de execu√ß√£o cresce muito r√°pido.

8. O(n!) ‚Äî Tempo fatorial
Exemplo: Resolver o problema do Caixeiro Viajante (TSP) com for√ßa bruta.
O tempo de execu√ß√£o cresce fatorialmente com o tamanho da entrada.
Pior caso: Uma das piores poss√≠veis, pois o n√∫mero de opera√ß√µes explode mesmo para entradas relativamente pequenas.

Cada uma dessas classes de complexidade reflete diferentes n√≠veis de desempenho, sendo os tempos exponenciais e fatoriais os mais ineficientes.